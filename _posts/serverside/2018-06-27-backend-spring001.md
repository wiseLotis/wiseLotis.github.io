---
layout: post
title : "토비 - 오브젝트와 의존관계"
slug: "backend-spring001"
subtitle: "토비 스프링 3.1 요약 vol.스프링의 원리와 이해 - 1장"
description: ""
categories: spring serverside
tags: [spring]
comments: true
feed: true
google: true
sitemap :
 changefreq: daily
 priority: 1.0
feed : true
---
## 1.1 초난감 코드
(생략)
-----
## 1.2 분리

### 관심사의 분리 및 추출
 중복된 코드의 메소드를 추출
- 리펙토링 : 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성 하는 작업 또는 기술.
코드 내부의 설계가 개선 되어 가독성이 높아지고 변화에 효율적으로 대처가 가능하므로 생산성과 품질이 향상된다.  

### 상속을 통한 확장
- 템플릿 멤소드
변하지 않는 기능은 슈퍼클래스에 정의하고,
잦은 변경이나 확장이 필요한 기능은 추상메소드와 훅메소드*를 이용해서 서브 클래스에서 정의 .
훅메소드 : 빈메소드 or 디폴트 기능을 오버라이딩가능하도록 정의해 놓음.

- 팩토리 메소드
서브클래스에서 오브젝트 생성과 클래스를 결정할 수 있도록 미리 정의해 놓은 메소드
슈퍼클래스 코드에서 서브 클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용

### 상속의 단점
- 자바는 클래스의 다중상속을 허용하지 않음.
- 상하위 클래스간의 관계가 밀접하다.
- 슈퍼클래스의 변경이 있을때 모든 서브 클래스를 변경해야 할 수 있음. (이를 위해 슈퍼클래스가 변경되지 않도록 제약을 걸어야 할 수 있음.)

다이아몬드 문제 :  다중상속 <br>
java가 클래스의 다중상속을 지원하지 않는 이유는 무엇일까 ?<br>
이유는 복잡성과 모호함의 증가이다.
다이아몬드 문제는 말그대로 클래스의 상속관계의 모형이 다이아 모양이라서 다이아 문제라고 말하는데,
예를 들어 Button이라는 클래스가 있고 Button은 Rectangle과 Clickable이라는 클래스를 상속받고
Rectangcle과 Clickable은 Object를 상속받았다.
Equals()메소드가 Button을 호출했을대 Button클래스는 Rectangle로 볼 수 있을까? 아니면 Clickable 클래스로 볼 수 있을까?  <br>
Button의 특정 기능이 어떤 부모클래스의 기능을 상속받은것인지 알 수 없는 모호함이 있다.
https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem
그러나 다른 언어에서는 다중상속을 지원하고 이를 해결할 수 있는 방법이 없는것도 아닌것 같음.
다중상속은 유용하다 VS 다중상속은 위험하고 유용하지 않다
의 논의가 계속 되고 있는 것 같음.  
그래서 Jav에서는 Interfac를 이용해서 다중상속을 지원한다. 또한 Java8 부터는 Interface에 기본메소드를 도입했다.
java8은 B,C가 A의 추상클래스를 서로 다른 방법으로 오버라이딩 해서 다이아몬드 문제를 일으킬 수 있음.
이경우 D 클래스에서 메소드를 재정의 하지 않은 경우 컴파일 에러가 날 수 있음.  

----
## 1.3 확장

### 인터페이스
두개의 클래스가 서로 긴밀하게 연결 되지 않도록 중간에 추상적인 느슨한 연결 고리를 만들어 주기 위한 인터페이스를 사용할 수 있다.
추상화란 어떤 것들의 공통적인 성격을 뽑아내서 분리하는 작업이다.  

### 관계설정 책임의 분리
UserDao와 ConnectionMaker간 관계 설정을 누가 해주는가! 의 문제임.  UserDao에서 ConnectionMaker의 관계를 설정하는 것은 비합리적임
기껏 클래스를 분리 해놓고서 Connection에 변경이 있을때 Dao를 변경해야 하기때문
UserDao가 Connectionmaker 인터페이스 외에는 어떤 클래스와도 관계를 갖지 않도록 해야함.
관계설정의 책임을 클라이언트에게 떠넘김

### 원칙과 패턴
- SRP Single Responsibility Principle : 단일 책임의 원칙
- OCP Open Closed Principle: 개방 폐쇄의 원칙 - 클래스나 모듈은 확장에는 열려있고, 변경에는 닫혀 있어야 함.
- LSP Liskov Subsitution Principle : 리스코프 치환 원칙
- ISP Interface Segregation Principle : 인터페이스 분리 원칙
- DIP Dependency Inversion Principle : 의존관계 역전의 원칙

### 높은 응집도와 낮은 결합도
- 높은 응집도 : 하나의 모듈 클래스가 하나의 책임과 관심사에만 집중 , 변화가 일어났을때 해당 모듈에서만 변화가 커야 함.
- 결합도 : 하나의 오브젝트가 변경이 일어날때 관계를 맺고 있는 다른 오브젝트에 변화를 요구하는 정도, 결합도가 낮을 수록 대응하는 속도가 높아지고, 구성이 깔끔해지며 확장이 편리해 짐.

### 전략패턴이란 ?
- 전략패턴  : 자신의 기능 맥락(Context) 에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 분리 시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있도록 하는 패턴

UserDaoTest <-> UserDao <-> ConnectionMaker

컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)가 사용할 전략(ConnectionMaker를 구현한 DConnectionMaker)를 컨텍스트의 생성자를 통해 제공

-----
## 1.4 제어의 역전 IoC(Inversion Of Control)
 제어의 역전은 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도 생성하지도 않는다. 또 자기도 어디서 어떻게 만들어지고 사용되는지 모른다. 모든 제어 권한을 다른 대상에게 위임한다.
즉 제어의 역전에서는 프레임워크나 컨테이너 같이 어플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 등을 관장하는 존재가 필요하다.  

### 팩토리
전략 패턴에서 클라이언트(UserDaoTest)에게 떠넘겼던 제어의 책임을 또 분리해 낼 수 있다.
* 팩토리 - 객체의 생성방법을 결정하고 오브젝트를 돌려주는 것  

* 라이브러리 VS 프레임 워크 *
라이브러리와 프레임워크의 차이점은 제어권에 있다.
라이브러리를 사용하는 코드는 어플리케이션의 흐름을 직접 제어 하면서 동작중에 필요한 기능이 있을때 능동적으로 라이브러리를 사용함.
프레임워크는 어플리케이션 코드가 프레임워크에 의해서 사용 되어 프레임워크가 흐름을 주도하는 중에 코드를 사용하도록 만든 방식이다.  즉 제어의 역전 개념이 적용 되어 있어야 함.

----
## 1.5 스프링의 IoC
### 어플리케이션 컨텍스트
- 빈 : 스프링이 직접 만들고 관계를 부여하는 오브젝트 (자바빈이나 EJB에서는 오브젝트 단위의 어플리케이션 컴포넌트를 말함).
- 빈팩토리 : 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부름.
* 어플리케이션 컨텍스트 사용시 장점 *
- 어플리케이션 컨텍스트: 빈 팩토리를 확장한 것 // IoC컨테이너 , 스프링 컨테이너 라고도 부름.
1. 클라이언트는 구체적인 팩토리 클래스를 알필요가 없다.
2. 종합 IoC 서비스를 제공해준다.  (관계설정, 만들 방식, 시점 전략, 자동생성, 후처리, 정보조합, 설정방식의 다변화, 인터셉팅 등)
- ApplicationConfigApplicationContext :  어노테이션을 이용하기 위해서 사용 하는 클래스
- getBean(methodName, class): ApplicationContext가 관리하는 오브젝트를 요청  
ex) context.getBean("userDao", UserDao.class)  ; //getBean()은 기본적으로 Object 타입을 리턴하므로 제네릭 메소드 방식을 이용해 두번째 파라미터에 리턴타입을 줄 수 있음.
- '@Configuration : 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스
- '@Bean : 오브젝트를 만들어 주는 메소드
* 제네릭 메소드 방식 *

----
## 1.6 싱글톤 레지스트리와 오브젝트 스코프

### 어플리케이션 컨텍스트 -> 싱글톤 레지스트리
getBean()에서 반환하는 오브젝트는 같은 오브젝트 임
스프링을 싱글톤으로 만든 이유? 스프링이 적용되는 주요 대상이 자바 엔터프라이즈기술을 사용하는 서버환경이기 때문이다. 클라이언트에서 요청이 올때마다 오브젝트를 새로 만들어서 생성하면 GC의 성능이 아무리 좋아도 부하가 생김.
* 서비스 오브젝트 (서블릿은 멀티스레드 환경에서 싱글톤으로 동작) *
서블릿 클래스 하나당 하나의 오브젝트를 만들고(서비스 오브젝트), 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유하여 사용함.


### Java 싱글톤 패턴의 한계
public Class UserDao{

private static UserDao INSTANCE;  
private UserDao(ConnectionMaker connectionMaker){
	this.connectionMaker = connectionMaker;
}

public staic sychronized UserDao getInstance(){
	if(INSTANCE == null) INSTANCE = new UserDao();
return INSTANCE;
}

- private 생성자를 가지고 있기 때문에 상속할 수 없다.  
- 싱글톤은 테스트 하기 힘들다
- 서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. (여러개의 JVM에서 분산되어 설치된 경우)
- 전역 상태를 만들 수 있기 때문에 바람직하지 않다.
<br>

### 싱글톤은 무상태(stateless)방식으로 만들어져야 한다.
인스턴트 필드값을 변경하고 유지 하는 상태유지 방식으로 만들면 여러사용자가 동시에 접속할 때 데이터가 엉망이 되어 버림.
대신 파라미터, 로컬변수, 리턴값을 이용 해야 함.
메소드 파라미터나, 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 여러 스레드가 변수의 값을 덮어 쓸 일이 없음.
** 읽기 전용 속성을 가진 정보라면 인스턴스 변수로 사용해도 상관이 없음. **

### 스코프
빈스코프 :  빈이 생성되고 존재하고, 적용되는 범위
스프링의 기본 스코프는 싱글톤
기타: 프로토타입스코프, request 스코프, 세션스코프 등

----

## 1.7 의존관계 주입

### 런타임시 의존관계 설정
A----->B (A가 B에 의존한다 ) :  B가 변하면 A 에 영향을 미친다, A가 B에 정의 된 메소드를 사용하는 경우.( 사용에 대한 의존관계)
UML에서 말하는 의존 관계는 설계 모델 관점
런타임의존관계 / 오브젝트 의존관계 : 런타임 시 만들어지는 의존관계  
의존 오브젝트 :  런타임 시에 의존 관계를 맺는 대상 , 실제 사용대상인 오브젝트
DI 컨테이너 :  런타임의존관계를 설정해주는 DI작업을 주도하고, 오브젝트의 생성 과 초기화, 제공 작업을 수행 (DaoFactory)

### 의존관계 검색
의존관계검색: 자신이 필요로 하는 의존 오브젝트를 능동적으로 검색 하여 스스로 컨테이너에 요청.
의존관계 주입과 의존관계 검색 중에 어떤게 더 나을 까? <br>
의존관계 주입 방식이 더 깔금하지만 의존 관계 검색을 꼭 써야 할때가 있음.
서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한번은 의존 검색 방식을 사용하여야 함. (-> 스프링이 미리 만들어 제공하고 있음. )

### 의존관계 주입 응용
- 기능구현의 교환
- 부가기능 추가

### 메소드를 이용한 주입
- 생성자를 이용한 의존관계 주입
: 한번에 여러개의 파라미터를 받을 수 있음. 그러나 파라미터의 갯수가 많아지고 비슷한 파라미터가 여러개일 때 실수 할 수 있음.

- 수정자 메소드를 이용한 의존관계 주입 (set으로 시작)
: 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것 , 입력값 검증이나 그 밖의 작업을 수행할 수 있음.  
외부로부터 제공받은 오브젝트 레퍼런스를 저장해두었다가 내부의 메소드에서 사용하게 하는 DI방식에서 활용 .
XML 사용시 자바빈 규약을 따르므로 사용이 편리함

- 일반 메소드를 이용한 의존관계 주입 (set으로 시작)
: 한번에 여러개의 파라미터를 받을 수 있음.  임의의 초기화 메소드를이용 적절한 개수의 파라미터를 가진 여러개의 초기화 메소드를 만들 수 있어 생성자 보다 낫다.

### XML을 이요한 설정
Java코드 의존성 주입 단점: 일일이 자바 코드를 만드는 것이 번거롭고, 틀에 박힌 구조가 반복된다, DI 구성이 바뀔때마다 JAVA코드를 수정하고 컴파일 해줘야 함.
XML 장점: 1. 단순 텍스트 파일이므로 다루기 쉽다.
2. 쉽게 이해할 수 있으며 별도의 빌드 작업이 없다.
3. 환경 변경 시 빠르게 반영할 수 있다.
4. 스키마, DTD를 이용 포맷을 따라 작성 되었는지 확인 할 수 있다.
'@configuration -> <beans> , '@Bean - > <bean>
* xml은 리턴타입을 지정하지 않아도 됨. class 는 오브젝트를 만들 때 사용하는 클래스 이름.
<property> 태그를 이용해서 의존 오브젝트와의 관계를 정의함.
property는 name과 ref 어트리뷰트를 가지고, name은 프로퍼티 이름이고, ref는 수정자 메소드를 이용해 주입해줄 빈의 이름.
userDao.setConnectionMaker(connectionMaker()); <br>
 <property name="connectionMaker" ref = "connectionMaker"/><br>

* DTD - 문서 구조 정의 *
<!DOCTYPE beans PUBLIC "-....(생략) ">  <br>
* 스키마 - BEANS , BEAN 태그 이외에 특별한 목적을 위해 별도의 태그를 사용 , 각각 별개의 스키마 파일에 정의되어 있고, 독립적인 네임스페이스를 사용해야함.
<br><beans xmls = "http://(생략..)" xmls:xsi="http://(생략..) schemaLocation="(생략)"><br>
DTD 보다 스키마를 사용하는 것이 바람직하다.  
<br>
GenericXmlApplicationContext context = new GenericXmlApplicationContext("userdao-servlet.xml"); <br>
userdao-servlet의 클래스 패스를 생성자로 넣는다.
특정 패키지의 상대 경로로 저장하고 싶은 경우.
new ClassPathXmlApplicationContext("daoContext.xml", UserDao.class);  <br>

------

## 요약

1. 관심사의 분리, 리팩토링
2. 전략패턴
3. 개방폐쇄원칙
4. 낮은 결합도, 높은 응집도
5. 제어의 역전, IoC
6. 싱글톤 레지스트리
7. 의존관계주입 DI  
8. 생성자 주입과 수정자 주입
9. xml 설정
